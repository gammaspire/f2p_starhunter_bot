############################################################
# In a channel of your choosing, type command and the bot will post
# list of filtered f2p worlds in order of early-to-late-to-no poof time
# use: 
#   $start_hop_loop [minutes]
# e.g., '$start_hop_loop 30' will print the list every 30 minutes in the channel
############################################################  

from discord.ext import commands
import asyncio
from discord import app_commands, Interaction

from hoplist_utils import generate_hoplist_text, send_hoplist_message
from scheduler_utils import scheduler
from universal_utils import load_json_file, save_json_file

from config import GUILD


class Hop_Loop(commands.Cog):
    
    def __init__(self, bot):
        self.bot = bot

    # look! another helper function!
    async def _start_loop(self, channel, guild_id, minutes, send_func):
        
        # check if the job_id already exists...
        job_id = f"scheduled_msg_hoplist_{guild_id}"
        if scheduler.get_job(job_id):
            await send_func('There is already a Hop Loop running in this server!')
            return

        # validate minutes input
        if minutes < 1:
            await send_func("Interval must be at least 1 minute.")
            return

        try:
            # unique identifier for a Discord CHANNEL
            channel_id = channel.id

            # notify user which channel will receive updates
            await send_func(f"The Hop List post will be updated in this channel every {minutes} minute(s)!")

            # send the initial message and get its message ID
            text = await generate_hoplist_text()
            loop_message = await channel.send(text)
            message_id = loop_message.id

            # scheduler functions must be non-async functions
            # this function schedules the async (send_hoplist_message()) to run inside of the bot's loop
            def run_job():
                try:
                    asyncio.run_coroutine_threadsafe(
                        send_hoplist_message(self.bot.get_channel(channel_id), message_id),
                        self.bot.loop)
                except Exception as e:
                    print(f"[Error] Failed to update Hop List message: {e}")

            # only add job if it hasn't been added yet
            if not scheduler.get_job(job_id):
                scheduler.add_job(run_job, trigger='interval', minutes=minutes, id=job_id, misfire_grace_time=30)

            # load existing jobs if file exists
            all_jobs = load_json_file('scheduled_jobs/scheduled_hoplist_jobs.json') or {}

            # write the new job (corresponding to guild_id) and save channel_id, interval, message_id
            all_jobs[str(guild_id)] = {
                'channel_id': channel_id,
                'interval': minutes,
                'message_id': message_id}

            # save to JSON so it persists
            save_json_file(all_jobs, 'scheduled_jobs/scheduled_hoplist_jobs.json')

        except Exception as e:
            # print full traceback if anything fails
            import traceback
            traceback.print_exc()

    ############################################################
    # prefix command: $start_hop_loop
    ############################################################
    @commands.command(help='Sets up the bot to send a filtered list of f2p worlds, ordered by early-to-late-to-no poof time, in the designated channel every N minutes, where N is an integer. Restricted to @Mods role.\nPrefix example: $start_hop_loop 5')
    @commands.has_role('Mods')
    async def start_hop_loop(self, ctx, minutes=5):
        await self._start_loop(ctx.channel, ctx.guild.id, minutes, ctx.send)

    ############################################################
    # slash command: /start_hop_loop
    ############################################################
    @app_commands.command(
        name='start_hop_loop',
        description='Sends/updates the Hop List in the designated channel every N minutes. Restricted to @Mods.')
    @app_commands.checks.has_role("Mods")
    async def start_hop_loop_slash(self, interaction: Interaction, minutes: int = 5):

        # send_func handles confirmation messages
        async def send_func(msg: str):
            if not interaction.response.is_done():
                await interaction.response.send_message(msg)
            else:
                await interaction.followup.send(msg)

        # this handles the message posting + loop scheduling
        await self._start_loop(interaction.channel, interaction.guild_id, minutes, send_func)

#attaching a decorator to a function after the class is defined...
#previously used @app_commands.guilds(GUILD)
#occasionally, though, GUILD=None if not testing
#in that case, cannot use @app_commands.guilds() decorator. returns an error!
#instead, we 're-define' the slash command function in the class above
if GUILD is not None:
    Hop_Loop.start_hop_loop_slash = app_commands.guilds(GUILD)(Hop_Loop.start_hop_loop_slash)   

async def setup(bot):
    await bot.add_cog(Hop_Loop(bot))